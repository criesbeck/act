
<div>
  <p><strong>Model-driven:</strong> These projects are driven by the underlying model of the problem domain. These are typically created by systems analysts.</p>
  <p><strong>Example:</strong> "University courses have names, prerequisites, home departments, and offerings. There are calendar terms. A term may be a semester, quarter, or summer session. A term instance has a start and end date. An offering is a course for a given term instance, with a set of enrollees. Enrollees can be students, staff, ..."</p>
  <p><strong>Strengths:</strong> Models are critical for defining a coherent, consistent, and sufficiently complete definition of the business logic for an application. 
  </p>
  <p><strong>But:</strong> Models are terrible drivers of application development. They lead to substantial up-front infrastructure development, delayed user testing, and user interfaces presenting unintuitive abstractions and overly specific details. 
  </p>
</div> 

<div>
  <p><strong>Interface-driven:</strong> These projects are driven by a set of wireframes, information flows, design themes, and detailed screen mockups. These are created by graphic designers and user experience experts.</p>
  <p><strong>Example:</strong> "Here's the home screen, using the forest design theme. On this page, users see the branding and a quick overview in three panels of the three major services available. From this page, users can navigate to details screens for each service. They can also click Contact to go to the communications page. They can also enter a search key to ..."</p>
  <p><strong>Strengths:</strong> Mockups can be a quick way to test the comprehensibility, usability, and overall impression of an interface. Wireframe sequences can catch inconsistencies, gaps, and deadends in interaction flow. Developers are less likely to misunderstand what they should be implementing when they have a concrete user interface.
  </p>
  <p><strong>But:</strong> Mockups are terrible drivers of application development. They lead to substantial up-front design, featuritis, and delayed user testing. They make promises about the product that may be impossible to keep. They lead to developers adding widgets to user interfaces, such as search fields, that either don't work yet or have no useful purpose yet. They put blinders on the developers, who focus on implementing the design rather than solving the problem. 
  </p>
</div> 

<div>
  <p><strong>User-driven:</strong> These projects are driven by a feature requests collected in early surveys and pilot tests.</p>
  <p><strong>Example:</strong> "There should be a way to rank restrooms by cleanliness." "I'd like to be able to post a picture from my phone of really awful or nice restrooms." "How about a way to find out which public restrooms are least crowded at any given time?" "The screen should be more modern looking."</p>
  <p><strong>Strengths:</strong> Feature requests provide insight into what users think they want, and what they expect to see. 
  </p>
  <p><strong>But:</strong> Survey and pilot use feature requests lead to featuritis, complex interfaces, ad hoc application logic, and an unstable product path. This is not really user-driven. Unless your product is in people's hands and being actively used, you have no users, only people with opinions about what they want and need. 
  </p>
</div> 
